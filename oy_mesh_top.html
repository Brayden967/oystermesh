<!DOCTYPE html>
<meta charset="utf-8">
<style>
    body{
        background-color: #ffffff;
    }
    rect {
        fill: none;
        pointer-events: all;
    }

    .node {
        fill: #212121;
    }

    .link {
        stroke: #999;
    }

</style>
<body>
<div style="position:absolute;right:0">
    <input type="button" value="ALPHA" onclick="oy_button()" />
    <input type="button" value="BETA" onclick="oy_button2()" />
</div>
<script src="https://d3js.org/d3.v3.min.js"></script>
<script>
    window.OY_MESH_TOP_PREV = [[], []];
    function oy_mesh_top() {
        let oy_xhttp = new XMLHttpRequest();
        oy_xhttp.onreadystatechange = function() {
            if (this.readyState===4&&this.status===200) {
                let oy_mesh_top = JSON.parse(this.responseText);
                let oy_mesh_change = false;
                for (let i in oy_mesh_top[0]) {
                    let oy_node_prev = window.OY_MESH_TOP_PREV[0].indexOf(oy_mesh_top[0][i]);
                    if (oy_node_prev===-1) {
                        let node = {id:oy_mesh_top[0][i], x: 0, y: 0};
                        console.log("NODE PUSH: "+node.id);
                        nodes.push(node);
                        oy_mesh_change = true;
                    }
                    else window.OY_MESH_TOP_PREV[0].splice(oy_node_prev, 1);
                }
                //deletes nodes and links
                if (window.OY_MESH_TOP_PREV[0].length>0) {
                    console.log("DELETING "+window.OY_MESH_TOP_PREV[0]+" NODE(S)");
                    console.log(window.OY_MESH_TOP_PREV[0]);
                    for (let i in window.OY_MESH_TOP_PREV[0]) {
                        for (let x in nodes) {
                            if (nodes[x].id===window.OY_MESH_TOP_PREV[0][i]) {
                                links = links.filter(function(l) {
                                    return l.source.id !== nodes[x].id && l.target.id !== nodes[x].id;
                                });
                                nodes.splice(x, 1);
                                oy_mesh_change = true;
                                break;
                            }
                        }
                    }
                }
                let oy_link_keep = [];
                for (let i in oy_mesh_top[1]) {
                    let oy_link_push = true;
                    for (let x in window.OY_MESH_TOP_PREV[1]) {
                        if ((window.OY_MESH_TOP_PREV[1][x][0]===oy_mesh_top[1][i][0]&&window.OY_MESH_TOP_PREV[1][x][1]===oy_mesh_top[1][i][1])||
                            window.OY_MESH_TOP_PREV[1][x][0]===oy_mesh_top[1][i][1]&&window.OY_MESH_TOP_PREV[1][x][1]===oy_mesh_top[1][i][0]) {
                            oy_link_push = false;
                            break;
                        }
                    }
                    if (oy_link_push===true) {
                        let node_collect = [];
                        nodes.forEach(function(target) {
                            if (target.id===oy_mesh_top[1][i][0]||target.id===oy_mesh_top[1][i][1]) node_collect.push(target);
                        });
                        if (node_collect.length===2) {
                            console.log("LINK PUSH: "+node_collect[0].id+" <-> "+node_collect[1].id);
                            links.push({source: node_collect[0], target: node_collect[1]});
                            oy_mesh_change = true;
                        }
                    }
                    else oy_link_keep.push(i);//any keys in here are safe from link deletion
                }
                if (oy_link_keep.length>0) {
                    for (let i in window.OY_MESH_TOP_PREV[1]) {
                        if (oy_link_keep.indexOf(i)===-1) {
                            links = links.filter(function(l) {
                                return (l.source.id !== window.OY_MESH_TOP_PREV[1][i][0] && l.target.id !== window.OY_MESH_TOP_PREV[1][i][1])||
                                    (l.source.id !== window.OY_MESH_TOP_PREV[1][i][1] && l.target.id !== window.OY_MESH_TOP_PREV[1][i][0]);
                            });
                            oy_mesh_change = true;
                            console.log("LINK DELETE: "+window.OY_MESH_TOP_PREV[1][i][0]+" <-> "+window.OY_MESH_TOP_PREV[1][i][1]);
                        }
                    }
                }
                if (oy_mesh_change===true) restart();
                window.OY_MESH_TOP_PREV = oy_mesh_top;
                setTimeout("oy_mesh_top()", 1000);
            }
        };
        oy_xhttp.open("GET", "http://central.oyster.org/oy_mesh_top.php", true);
        oy_xhttp.send();
    }

    window.COUNTER = 0;
    var width = 400,
        height = 400;

    var fill = d3.scale.category20();

    var force = d3.layout.force()
        .size([width, height])
        .nodes([]) // initialize with a single node
        .linkDistance(30)
        .charge(-60)
        .on("tick", tick);

    var svg = d3.select("body").append("svg")
        .attr("width", width)
        .attr("height", height)

    svg.append("rect")
        .attr("width", width)
        .attr("height", height);

    var nodes = force.nodes(),
        links = force.links(),
        node = svg.selectAll(".node"),
        link = svg.selectAll(".link");

    restart();

    function oy_button() {
        for (let x in nodes) {
            if (nodes[x].id==="06d246e0965a40f4760adabe3a62c88bdff7af46") {
                links = links.filter(function(l) {
                    return l.source.id !== nodes[x].id && l.target.id !== nodes[x].id;
                });
                nodes.splice(x, 1);
                break;
            }
        }
        restart();
    }

    function oy_button2() {
        let node_collect = [];
        nodes.forEach(function(target) {
            if (target.id===3||target.id===4) node_collect.push(target);
        });
        links.push({source: node_collect[0], target: node_collect[1]});
        console.log(links);
        restart();
        console.log(links);
    }
    function mousedownCanvas() {

        /*
        var point = d3.mouse(this),
            node = {x: point[0], y: point[1]},
            n = nodes.push(node);

        // add links to any nearby nodes
        nodes.forEach(function(target) {
            var x = target.x - node.x,
                y = target.y - node.y;
            if (Math.sqrt(x * x + y * y) < 30) {
                links.push({source: node, target: target});
            }
        });

        restart();
*/

        let node1 = {id:"bob", x: 200, y: 200};
        n = nodes.push(node);

        /*
        nodes.forEach(function(target) {
            if (target.id==="bob") {
                nodes.push(node);
                links.push({source: node, target: target});
            }
        });
        */
        links.push({source: node1, target: node2});

        restart();
        console.log(nodes);
        console.log(links);

    }

    function mousedownNode(d, i) {
        nodes.splice(i, 1);
        links = links.filter(function(l) {
            return l.source !== d && l.target !== d;
        });
        d3.event.stopPropagation();

        restart();
    }

    function tick() {
        link.attr("x1", function(d) { return d.source.x; })
            .attr("y1", function(d) { return d.source.y; })
            .attr("x2", function(d) { return d.target.x; })
            .attr("y2", function(d) { return d.target.y; });

        node.attr("cx", function(d) { return d.x; })
            .attr("cy", function(d) { return d.y; });
    }

    function restart() {
        node = node.data(nodes);

        node.enter().insert("circle", ".cursor")
            .attr("class", "node")
            .attr("r", 5)
            .on("mousedown", mousedownNode);

        node.exit()
            .remove();

        link = link.data(links);

        link.enter().insert("line", ".node")
            .attr("class", "link");
        link.exit()
            .remove();

        force.start();
    }
    oy_mesh_top();

</script>